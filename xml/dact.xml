<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Decaffeinated Alpino Corpus Tool</title>
    </info>
    <sect1>
        <title>Introduction</title>
        <para>If Dact could be started correctly, you can open a corpus in Dact. Dact can only work with Dact corpora, but can convert other types of corpora to a Dact corpus:</para>
        <itemizedlist>
            <listitem>
                <para>Compact corpora, consisting of a data and index file (recognizable by
                        the <filename>.data.dz</filename> and <filename>.index</filename> extensions).</para>
            </listitem>
            <listitem>
                <para>Directory corpora, which are directories that contain parses.</para>
            </listitem>
        </itemizedlist>
        <para>Dact corpora can be opened using the <emphasis>Ctrl+o</emphasis> keyboard shortcut (on OS X, use Cmd instead of Ctrl). This will show a dialog that allows you to open the corpus. If you prefer, you can use the <emphasis>File - Open…</emphasis> menu item as well.</para>
        <figure>
            <title>Dact main window</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/dact-osx.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>After opening a corpus, the window will resemble that in the screenshot above. The
            main Dact Window consists of a filter field and three tabs:</para>
        <itemizedlist>
            <listitem>
                <para>The Tree tab shows all entries with matching nodes in the corpus that match your filter query. You can click on an entry to show it dependency tree. You can also open the Inspector using the button in the upper right corner (<emphasis>Ctrl+i</emphasis>) and inspect the attributes of individual nodes in the dependency tree by selecting them.</para>
            </listitem>
            <listitem>
                <para>The Statistics tab shows the occurrences of values of a specific attribute for all the nodes in the corpus that match your filter query. You can specify which attribute with the dropdown menu on this tab.</para>
            </listitem>
            <listitem>
                <para>The Sentences tab shows the entries containing matching nodes as sentences, and highlights them.</para>
            </listitem>
        </itemizedlist>
        <para>Although the corpus can be browsed entry by entry, most functionality of Dact is query-driven. After a short introduction to the query language in the next section, you will be prepared to use other functionality of Dact.</para>
        <sect2>
            <title>Getting a corpus</title>
            <para>Dact comes with a download tool for corpora. Select <emphasis>Tools – Download corpus…</emphasis> and choose the corpus you want to download, and press <emphasis>Download</emphasis>. You will be asked where you want to store the corpus. After downloading and unpacking the corpus you will have to open it manually using <emphasis>File – Open…</emphasis>.</para>
            <figure>
                <title>Download Corpora window</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/download-corpora-window.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </sect2>
    </sect1>
    <sect1>
        <title>Queries</title>
        <para>Queries are written in the <link xlink:href="http://en.wikipedia.org/wiki/XPath">XPath</link> query language.</para>
        <sect2>
            <title>Matching a node</title>
            <para>Every node in the tree is represented as an <emphasis>node</emphasis> element. You can match any node in the tree by using two forward slashes:</para>
            <programlisting>//node</programlisting>
            <para>Of course, normally, you would want to match nodes with certain restrictions based on attributes of a node. Such restrictions can be entered between square brackets (<literal>[</literal> and <literal>]</literal>). And attributes are prefixed by the ‘at’ sign (<literal>@</literal>). Commonly-used attributes are:</para>
            <variablelist>
                <varlistentry>
                    <term>rel</term>
                    <listitem><para>relation label</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>cat</term>
                    <listitem><para>category</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>pos</term>
                    <listitem><para>part of speech tag</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>root</term>
                    <listitem><para>the root/stem of a lexical node</para></listitem>
                </varlistentry>
            </variablelist>
            <para>For instance, the following query will match all nodes with the <emphasis>pos</emphasis> attribute, or in other words lexical nodes:</para>
            <programlisting>//node[@pos]</programlisting>
            
            <para>We can also restrict the selection by requiring that an attribute has a specific value using the equals sign (<emphasis>=</emphasis>). For instance, the following query will match all nodes, which have a <emphasis>pos</emphasis> attribute with the value <emphasis>det</emphasis>:</para>
            <programlisting>//node[@pos="det"]</programlisting>
            
            <para>Such conditions can also be combined. Using the <emphasis>and</emphasis> operator will require both conditions to be true, while the <emphasis>or</emphasis>operator requires one of the conditions to be true. The following query will match all nodes with a <emphasis>su</emphasis> dependency relation, that also have <emphasis>det</emphasis> as their part of speech tag:</para>
            <programlisting>//node[@rel="su" and @pos="det"]</programlisting>
            
            <para>There are some functions available in XPath which may be useful. For example using <function>not</function> we could find any node that does not match a certain condition. Say we want to match everything except nouns, we could write:</para>
            <programlisting>//node[not(@pt="n")]</programlisting>
            
            <para>Or say we wanted to match everything except nouns that are lexical nodes starting with the letter <emphasis>v</emphasis>. We can use the <function>starts-with</function> function to require that the <emphasis>root</emphasis> attribute starts with the text <emphasis>v</emphasis>. The <emphasis>and</emphasis> operator will tie them together.</para>
            <programlisting>//node[not(@pt) and starts-with(@root, "v")]</programlisting>
            
            <para><function>contains</function> is another function that works just like <function>start-with</function>, except it match if the text is found anywhere in the attribute its value, not just at the beginning.</para>
            <para>We can also make queries based on the structure of a tree. For example, the following query will match any node with a <emphasis>su</emphasis> dependency relation that has a determiner: one of the children of the matching node is a node which<emphasis>pos</emphasis> attribute has the value <emphasis>det</emphasis>.</para>
            <programlisting>//node[@rel="su" and node[@pos="det"]]</programlisting>
            
            <para>Now that query matched the <emphasis>su</emphasis> node, but we can also match the <emphasis>det</emphasis> node. This is useful in the Statistics Window, where the matching nodes are read. This query will do just that:</para>
            <programlisting>//node[@rel="su"]/node[@pos="det"]</programlisting>
            
            <para>It first finds the subject nodes, and then matches all the determiners found in these nodes. We can continue this to for example find all the nouns in the noun phrase in a preposition phrase. We first find the preposition phrase somewhere in the tree (mind the double slash), then find the noun phrase among one of its children (the single slash), and then find a noun among the noun phrase its children.</para>
            <programlisting>//node[@cat="pp"]/node[@cat="np"]/node[@pt="n"]</programlisting>
            
            <para>This goes down deeper into the tree, but we can also move back up in the tree using double dots. Say we wanted to select all the siblings of a noun node, we can use .. to move up to the parent of the noun node, and then select all the children of this parent node:</para>
            <programlisting>//node[@pt="n"]/../node</programlisting>
            
            <para>Or we could select all nodes of which the parent node has a child node which is a noun:</para>
            <programlisting>//node[../node[@pt="n"]]</programlisting>
            
            <para>Note that strings, i.e. the text between quotes and attributes can be used interchangeably since an attribute has a string as a value. For example, say we would want to do something silly and try to find all lexical nodes with an attribute <emphasis>pt</emphasis> that has the same value al the word of the node, which would mostly be just the letter <emphasis>n</emphasis>. The word is accessible through the <emphasis>word</emphasis> attribute. So we end up comparing the <emphasis>word</emphasis> attribute with the <emphasis>pt</emphasis> attribute:</para>
            <programlisting>//node[@pt=@word]</programlisting>
            
            <para>And we are not just bound to the attributes of the current node. Say we wanted to find examples the dutch verb<emphasis>krijgen</emphasis> used in a passive form. To do this, we have to look for sentences where the subject of the sentence is also the object of the verb phrase. A translation takes place. In the corpus this is indicated by an <emphasis>index</emphasis> attribute. This attribute contains the same value on both nodes. I.e.. when we want to see translation 1, this query will highlight both the nodes before and after the translation:</para>
            <programlisting>//node[@index=1]</programlisting>
            
            <para>Now using that knowledge we can find the node which contains the verb <emphasis>krijgen</emphasis>, a subject, and a object in the verb complement which both share the same value for <emphasis>index</emphasis>:</para>
            <programlisting>//node[ node[@rel="hd" and @root="krijg"] and node[@rel="su"]/@index=node[@rel="vc"]/node[@rel="obj2"]/@index ]</programlisting>
            <para>(This query was taken from the <link xlink:href="http://www.let.rug.nl/~vannoord/alp/Alpino/TreebankTools.html">manual for Treebank Tools</link>, which contains some more interesting queries.)</para>
            
            <note>
                <para>Please do note that Dact expects queries that return nodes. A highlight query returning the value of an attribute wont highlight any nodes.</para>
            </note>
        </sect2>
        <sect2>
            <title>Exploring a corpus</title>
            <para>The left pane on the Tree tab shows a list of corpus entries, where each entry represents a parsed sentence containing at least one node that matched your filter query.</para>
            <para>After typing the query, press the <emphasis>Enter</emphasis> key, and Dact will start filtering the corpus. If you want to interrupt filtering, press the <emphasis>Esc</emphasis> key. You can also pick one of your previous queries form the history using the arrow on the right of the filter field.</para>
            <para>Using the <emphasis>Next</emphasis> and <emphasis>Previous</emphasis> arrows in the top left menu bar, you can walk through each found entry. Or you can use the <emphasis>Ctrl+Down</emphasis> and <emphasis>Ctrl+Up</emphasis> shortcuts.</para>
        </sect2>
        <sect2>
            <title>Highlighting nodes</title>
            <para>After selecting an entry, its parse tree is shown in the right pane. To easier to spot interesting phenomena, or test a query, you can enter a separate query in the highlight field. Each node matching the highlight query will be coloured:</para>
            <figure>
                <title>Highlighted nodes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/highlighted-nodes.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Initially, the filter query is used as the highlight query.</para>
            <para>Matching nodes will be highlighted in the tree in green (you can alter this colour in the Preferences). The buttons <emphasis>Zoom In</emphasis> and <emphasis>Zoom Out</emphasis> can be used to scale the tree. <emphasis>Previous Node</emphasis> and <emphasis>Next Node</emphasis> will walk you through all the matching nodes. You can use <emphasis>Ctrl+Left</emphasis> and<emphasis>Ctrl+Right</emphasis> as well. The focussed node will then be marked by a slightly thicker border. Normally, the scroll wheel is used for panning the tree. but when you press <emphasis>Ctrl</emphasis>, scrolling will cause the tree to scale. <emphasis>Ctrl+=</emphasis> and <emphasis>Ctrl+-</emphasis> can also be used to zoom in and out, and <emphasis>Ctrl+0</emphasis> resets the zoom level to show the whole tree, just like <emphasis>Fit</emphasis> button on the toolbar does.</para>
            <para>The leaf nodes have tool tips showing more details about the node.</para>
            <para>Below the tree the sentence is shown, and the parts in the sentence represented by the matching nodes are highlighted.</para>
        </sect2>
        <sect2>
            <title>Inspecting nodes</title>
            <para>If you want to know more about a node, you can select it and open the Inspector by clicking its button on the right hand side of the toolbar, pressing <emphasis>Ctrl+i</emphasis> or by enabling it in the <emphasis>View</emphasis> menu. This is very useful for writing queries.</para>
            <figure>
                <title>Main window with inspector attached</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/inspector.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>The Inspector will show you every attribute the focussed node has. You can right-click an attribute and use the context menu to directly add it to your search query.</para>
            <tip>
                <para>The Inspector is detachable and can be torn of the Main window.</para>
            </tip>
        </sect2>
        <sect2>
            <title>Gathering statistics</title>
            <para>The Statistics tab shows which values can be found for a certain attribute of the matching nodes throughout the corpus. These nodes can be filtered using the same XPath queries. If a node does match the filter, but does not have the attribute, it will be counted as <emphasis>[missing attribute]</emphasis>.</para>
            <figure>
                <title>Statistics tab</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/statistics-tab.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Make sure to use a filter which matches the nodes you want to know the values of. For example, say we wanted to know how often every preposition occurs in a preposition phrase. We need to filter for the preposition nodes that are children of a preposition phrase node:</para>
            <programlisting>//node[@cat="pp"]/node[@pt="vz"]</programlisting>
            <para>If you are unsure whether your filter will match too many or too little nodes, try to test it visually in the Tree tab by using your query as the highlight query.</para>
            <para>Because we want to know how often the word occurs, we select the <literal>word</literal> or <literal>lemma</literal> attribute from the drop-down menu.</para>
            <para>The <emphasis>Value</emphasis> column shows all the distinct values found, and the <emphasis>Nodes</emphasis> column shows how often nodes with these values where encountered. The <emphasis>percentage</emphasis> column puts this number into perspective by showing how much this is as a percentage of the total count of found values. This total is shown in the bottom right of the window, as is the number of distinct values (i.e. the number of rows in the table).</para>
            <para>You can double-click one of the rows to search for all nodes that together are summed up in that row. Dact will automatically generate a new filter query for you.</para>
            <para>When copying rows to the clipboards, they will be pasted as a tab-separated plain-text table. Excel and many other programs are able to import this format when pasting it into a document.</para>
        </sect2>
        <sect2>
            <title>Exporting Statistics</title>
            <para>The results from the Statistics tab can be saved in various formats: plain text, HTML, Excel worksheet and CSV. Go to the <emphasis>File - Save as…</emphasis> menu and select the file type from the drop-down menu in the save dialog.</para>
            <tip>
                <para>Note that this menu item also works for other the Sentences tab.</para>
            </tip>
        </sect2>
        <sect2>
            <title>Sentences</title>
            <para>To quickly get an impression which part of a sentence matches a query, you can use the <emphasis>Sentences</emphasis> tab.</para>
            <figure>
                <title>Sentences tab</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/sentences-tab.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>The window highlights the part of a sentence which matches the query for all the sentences in the corpus where at least one matching node is found.</para>
            <para>You can select alternative display modes using the drop-down menu. Currently three methods are implemented:</para>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Complete Sentence</emphasis> shows the matching nodes in the sentence on a different background. Nested matches have a more opaque background. The colour can be changed in Dact's Preference Window.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Only Matches</emphasis> shows only partial sentences of the nodes that matched.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Keywords in Context</emphasis> shows all the matches directly underneath each other and prints the rest of the sentence left and right of the match. These colours can also be configured in Dact's Preference Window.</para>
                </listitem>
            </itemizedlist>
        </sect2>
    </sect1>
    <sect1>
        <title>Converting corpora</title>
        <para>Dact can only work with Dact corpora, but it can create these from any Directory and Compact corpus. To convert a Directory or Compact corpus, go to the <emphasis>Tools - Convert corpus</emphasis> submenu, and choose your type. Dact will prompt you for the location of your corpus, and where to save the new Dact corpus. Afterwards you can open the newly generated Dact corpus using the <emphasis>File - Open…</emphasis> menu item. </para>
        <note>
            <para>Note that <emphasis>your original corpus won't be affected</emphasis> in this process.</para>
        </note>
    </sect1>
    <sect1>
        <title>Configuring Dact</title>
        <para>Dact has some preferences you can change it to suit more to your needs. You can configure the font and colours of the interface. You can find these in the Preference window, which you can find in <emphasis>Edit</emphasis> menu. (On OS X, you will find it in the application menu like any other OS X application.) Changes are automatically applied and saved.</para>
        <para>If you accidentally mess up, you can always return to the default preferences Dact ships with by clicking the <emphasis>Return to Default</emphasis> button in a tab. The preferences will be restored to their default values.</para>
        <figure>
            <title>Preferences window</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/preferences-window.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <sect2>
            <title>Font and colours</title>
            <para>Dact allows you to choose your own colours and font used in the interface to some extend.</para>
            <para>Note that the OS X version of Dact does not have a <emphasis>Font</emphasis> tab. In the other versions of Dact you can change the font that is used for the buttons and lists throughout Dact.</para>
        </sect2>
        <sect2>
            <title>Network</title>
            <para>Dact's <emphasis>Download corpus</emphasis>, <emphasis>Open remote corpus</emphasis> and <emphasis>Parse sentences</emphasis> features use web services to function. The addresses of these web services can be changed.</para>
            <note>
                <para>Note that not all of these features may be enabled in your version of Dact as of the time of writing not all of the required web services are publicly available.</para>
            </note>
        </sect2>
    </sect1>
    <sect1>
        <title>Marcos</title>
        <para>Dact supports macros in its XPath queries. You can insert simple placeholders in your query which are expanded before a query is evaluated. A placeholder is the name of the macro surrounded by percentage signs (<literal>%</literal>).</para>
        <sect2>
            <title>Using a macro</title>
            <para>Given you have loaded a file with the following macro:</para>
            <programlisting>interesting = """ @rel="su" or @rel="vc" """</programlisting>
            <para>When you enter the following query in to the filter query field:</para>
            <programlisting>//node[%interesting%]</programlisting>
            <para>Dact replace the placeholder, and execute the following query:</para>
            <programlisting>//node[ @rel="su" or @rel="vc" ]</programlisting>
            <para>Since Dact only does simple text replacement, you can also use invalid or partial XPath code as replacement. As long as the expanded query is valid, Dact will accept it.</para>
        </sect2>
        <sect2>
            <title>Loading a file with Macros</title>
            <para>You can load a file with macros with the <emphasis>Macros - Load file…</emphasis> menu item. When the file is successfully loaded, a submenu with the same name as the filename is visible in the <emphasis>Macros</emphasis> menu, containing all the macros in the file.</para>
            <para>When you have focused one of the XPath query fields in Dact, you can select one of the macros from the <emphasis>Macros</emphasis> menu to insert it at the position of your text cursor.</para>
        </sect2>
        <sect2>
            <title>Macros file syntax</title>
            <para>Macro files are rather simple and can be created with any plain text editor. Macros have the following syntax:</para>
            <programlisting>placeholder = """replacement"""</programlisting>
            <para><literal>placeholder</literal> is the name of your macro, and <literal>replacement</literal> the XPath code it will be replaced with. The name and replacement are separated by a <literal>=</literal>, and the replacement has to be surrounded by three pairs of double quotes. <literal>replacement</literal> may span several lines.</para>
            <para>Dact also expands macros while loading them. This way, you can use macros you defined earlier on in a file in your macros.</para>
            <figure>
                <title>Example of macros file</title>
                <programlisting><![CDATA[
b = """number(@begin)"""
e = """number(@end)"""

headrel = """ ( @rel="hd" or @rel="cmp" or @rel="mwp" or @rel="crd" or @rel="rhd" or @rel="whd" or @rel="nucl" or @rel="dp") """

precedes_head_of_smain = """
(  ancestor::node[@cat="smain"]/
             node[@rel="hd"]/%b% 
           > node[%headrel%]/%b% 
   or 
   ancestor::node[@cat="smain"]/
             node[@rel="hd"]/%b% 
           > %b% and @pos
)
"""
]]></programlisting>
            <caption>Notice how <literal>precedes_head_of_smain</literal> makes use of the <literal>headrel</literal> macro.</caption>
            </figure>
        </sect2>
    </sect1>
    <sect1>
        <title>Tools</title>
        <sect2>
            <title>Using tools</title>
            <para>In both the Tree and Sentences tab the individual files matching your filter query are shown. You can add additional entries to the context menu for these files by configuring tools. For example, you could configure a text editor to show the raw XML data of the selected sentence.</para>
            <para>If you have selected multiple files, Dact will start the selected tool once for each file.</para>
        </sect2>
        <sect2>
            <title>Configuring tools</title>
            <para>The path to a tools configuration file can be set in the Preferences of Dact. Once the path is set, the file is loaded when you open the tools context menu. If you update the file after that, Dact will reload it automatically.</para>
        </sect2>
        <sect2>
            <title>Tools configuration file syntax</title>
            <para>The syntax of the tools configuration file looks a lot like the one used by the macros. In addition to this, you can use <literal>%1</literal> as placeholder for the filename of the selected file as shown by Dact in the Tree tab. For example, to define an "Edit Text" menu entry: <programlisting>Edit Text = """gedit "~/treebanks/cdb/%1""""</programlisting></para>
            <tip>
                <para>In this example the complete path is surrounded by quotes, as the filename may contain spaces.</para>
            </tip>
            <para>Unfortunately, the XML files Dact uses are not accessible outside of the Dact database files. But if you have the raw XML files installed somewhere (e.g. in <literal>~/treebanks/cdb</literal>), you can refer to those.</para>
        </sect2>
        <sect2>
            <title>Tools for a specific treebank</title>
            <para>Because you cannot let the tools interact with the treebank, you might need to configure your tools differently for each treebank you use. E.g. your <literal>cdb.dact</literal> might need to use the files in <literal>~/treebanks/cdb</literal> while you have all your XML files for <literal>wikipedia.dact</literal> in <literal>/net/shared/treebanks/wikipedia</literal>.</para>
            <para>To allow you to specify a tool for just a few specific treebanks, you can add subsections to your tools configuration file with the path of the treebank files as name. Fortunately, you can use wildcards in these filenames. Only when the path of the currently loaded treebank matches this pattern, all tools in this subsection will be shown in the tools context menu.</para>
            <figure>
                <title>Example of macros file</title>
                <programlisting><![CDATA[
mark = """bash -c "echo \"%1\" >> ~/marked_entries.txt" """

[*/cdb.dact]
show xml = """gedit "~/treebanks/cdb/%1""""
email name = """bash -c "echo \"%1\" | sendmail -v someone@domain" """

[*/wikipedia*.dact]
show xml = """gedit "/net/shared/treebanks/wikipedia/%1""""
]]></programlisting>
                <caption>The <literal>show xml</literal> tool is specific for the treebank you currently use. The <literal>mark</literal> tool is not inside a section and will be shown for every treebank. The <literal>email name</literal> tool will only show up if your current treebank is named <literal>cdb.dact</literal>.</caption>
            </figure>
        </sect2>
    </sect1>
    <sect1>
        <title>Common errors</title>
        <sect2>
            <title>The application failed to initialize properly (0xc0000022)</title>
            <para>If you get the error <literal>The application failed to initialize properly (0xc0000022)</literal> it means that something is wrong with the DLL permissions. Presumably with the .dll files in the Dact distribution.</para>
            <para>You can fix this problem by opening a command prompt, and cd to the directory in which the Dact files reside. Then type:</para>
            <programlisting>cacls *.dll /E /G BUILTIN\Users:R</programlisting>
        </sect2>
    </sect1>
</article>
