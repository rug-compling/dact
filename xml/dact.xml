<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Decaffeinated Alpino Corpus Tool</title>
    </info>
    <sect1>
        <title>Introduction</title>
        <para>If Dact could be started correctly, you can open a corpus in Dact. Dact supports three
            kinds of corpora:</para>
        <itemizedlist>
            <listitem>
                <para>Dact corpora (recognizable by the <emphasis role="italic"
                    >.dact</emphasis> extension). Use of this corpus format is strongly recommended,
                    because it has superior performance in query processing.</para>
            </listitem>
            <listitem>
                <para>Compact corpora, consisting of a data and index file (recognizable by
                        the <emphasis role="italic">.data.dz</emphasis> and <emphasis role="italic"
                        >.index</emphasis> extensions).</para>
            </listitem>
            <listitem>
                <para>Directory corpora, which are directories that contain parses.</para>
            </listitem>
        </itemizedlist>
        <para>Dact and compact corpora can be opened using the <emphasis role="italic"
                >Ctrl+o</emphasis> keyboard shortcut, directory corpora using the <emphasis
                role="italic">Ctrl+d</emphasis>shortcut (on OS X, use Cmd instead of Ctrl). This
            will show a dialog that allows you to open the corpus. If you prefer, you can use
                the <emphasis role="italic">File - Open…</emphasis> and <emphasis role="italic">File
                - Open Directory…</emphasis> menu items as well.</para>
        <figure>
            <title>Dact main window</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/dact-osx-small.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>After opening a corpus, the window will resemble that in the screenshot above. The
            main Dact Window consists of two panes:</para>
        <itemizedlist>
            <listitem>
                <para>The entries pane (left) shows the list of corpus entries, here you can browse
                    and select entries.</para>
            </listitem>
            <listitem>
                <para>The detail pane (right) will contains more information about the entry that is
                    selected in the left pane. This information consists of a sentence and the
                    associated dependency tree.</para>
            </listitem>
        </itemizedlist>
        <para>Although the corpus can be browsed entry by entry, most functionality of Dact is
            query-driven. After a short introduction to the query language in the next section, you
            will be prepared to use other functionality of Dact.</para>
    </sect1>
    <sect1>
        <title>Queries</title>
        <para> Queries are written in the <link xlink:href="http://en.wikipedia.org/wiki/XPath"
                >XPath</link> query language.</para>
        <sect2>
            <title>Matching a node</title>
            <para/>
            <para>Every node in the tree is represented as an <emphasis role="italic"
                    >node</emphasis> element. You can match any node in the tree by using two
                forward slashes:</para>
            <programlisting>//node</programlisting>
            <para>Of course, normally, you’d want to match nodes with certain restrictions based on
                attributes of a node. Such restrictions can be entered between square brackets
                    (<emphasis role="italic">* and <emphasis role="italic">]</emphasis>). And
                    attributes are prefixed by the ‘at’ sign (<emphasis role="italic">@</emphasis>).
                    Commonly-used attributes are:</emphasis></para>
            <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">rel</emphasis>: relation label</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">cat</emphasis>: category</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">pos</emphasis>: part of speech tag</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">root</emphasis>: the root/stem of a lexical
                        node</para>
                </listitem>
            </itemizedlist>
            <para>For instance, the following query will match all nodes with the <emphasis
                    role="italic">pos</emphasis> attribute, or in other words lexical nodes:</para>
            <programlisting>//node[@pos]</programlisting>
            <para>We can also restrict the selection by requiring that an attribute has a specific
                value using the equals sign (<emphasis role="italic">=</emphasis>). For instance,
                the following query will match all nodes, which have a <emphasis role="italic"
                    >pos</emphasis> attribute with the value <emphasis role="italic"
                >det</emphasis>:</para>
            <programlisting>//node[@pos="det"]</programlisting>
            <para>Such conditions can also be combined. Using the <emphasis role="italic"
                    >and</emphasis> operator will require both conditions to be true, while
                    the <emphasis role="italic">or</emphasis>operator requires one of the conditions
                to be true. The following query will match all nodes with a <emphasis role="italic"
                    >su</emphasis> dependency relation, that also have <emphasis role="italic"
                    >det</emphasis> as their part of speech tag:</para>
            <programlisting>//node[@rel="su" and @pos="det"]</programlisting>
            <para>There are some functions available in XPath which may be useful. For example
                    using <emphasis role="italic">not</emphasis> we could find any node that doesn’t
                match a certain condition. Say we want to match everything except nouns, we could
                write:</para>
            <programlisting>//node[not(@pt="n")]</programlisting>
            <para>Or say we wanted to match everything except nouns that are lexical nodes starting
                with the letter <emphasis role="italic">v</emphasis>. We can use the <emphasis
                    role="italic">starts-with</emphasis> function to require that the <emphasis
                    role="italic">root</emphasis> attribute starts with the text <emphasis
                    role="italic">v</emphasis>. The <emphasis role="italic">and</emphasis> operator
                will tie them together.</para>
            <programlisting>//node[not(@pt) and starts-with(@root, "v")]</programlisting>
            <para><emphasis role="italic">contains</emphasis> is another function that works just
                    like <emphasis role="italic">start-with</emphasis>, except it match if the text
                is found anywhere in the attribute’s value, not just at the beginning.</para>
            <para>We can also make queries based on the structure of a tree. For example, the
                following query will match any node with a <emphasis role="italic"
                >su</emphasis> dependency relation that has a determiner: one of the children of the
                matching node is a node which<emphasis role="italic">pos</emphasis> attribute has
                the value <emphasis role="italic">det</emphasis>.</para>
            <programlisting>//node[@rel="su" and node[@pos="det"]]</programlisting>
            <para>Now that query matched the <emphasis role="italic">su</emphasis> node, but we can
                also match the <emphasis role="italic">det</emphasis> node. This is useful in the
                Statistics Window, where the matching nodes are read. This query will do just
                that:</para>
            <programlisting>//node[@rel="su"]/node[@pos="det"]</programlisting>
            <para>It first finds the subject nodes, and then matches all the determiners found in
                these nodes. We can continue this to for example find all the nouns in the noun
                phrase in a preposition phrase. We first find the preposition phrase somewhere in
                the tree (mind the double slash), then find the noun phrase among one of it’s
                children (the single slash), and then find a noun among the noun phrase it’s
                children.</para>
            <programlisting>//node[@cat="pp"]/node[@cat="np"]/node[@pt="n"]</programlisting>
            <para>This goes down deeper into the tree, but we can also move back up in the tree
                using double dots. Say we wanted to select all the siblings of a noun node, we can
                use .. to move up to the parent of the noun node, and then select all the children
                of this parent node:</para>
            <programlisting>//node[@pt="n"]/../node</programlisting>
            <para>Or we could select all nodes of which the parent node has a child node which is a
                noun:</para>
            <programlisting>//node[../node[@pt="n"]]</programlisting>
            <para>Note that strings, i.e. the text between quotes and attributes can be used
                interchangeably since an attribute has a string as a value. For example, say we
                would want to do something silly and try to find all lexical nodes with an
                    attribute <emphasis role="italic">pt</emphasis> that has the same value al the
                word of the node, which would mostly be just the letter <emphasis role="italic"
                    >n</emphasis>. The word is accessible through the <emphasis role="italic"
                    >word</emphasis> attribute. So we end up comparing the <emphasis role="italic"
                    >word</emphasis> attribute with the <emphasis role="italic"
                >pt</emphasis> attribute:</para>
            <programlisting>//node[@pt=@word]</programlisting>
            <para>And we are not just bound to the attributes of the current node. Say we wanted to
                find examples the dutch verb<emphasis role="italic">krijgen</emphasis> used in a
                passive form. To do this, we have to look for sentences where the subject of the
                sentence is also the object of the verb phrase. A translation takes place. In the
                corpus this is indicated by an <emphasis role="italic">index</emphasis> attribute.
                This attribute contains the same value on both nodes. Ie. when we want to see
                translation 1, this query will highlight both the nodes before and after the
                translation:</para>
            <programlisting>//node[@index=1]</programlisting>
            <para>Now using that knowledge we can find the node which contains the verb <emphasis
                    role="italic">krijgen</emphasis>, a subject, and a object in the verb complement
                which both share the same value for <emphasis role="italic">index</emphasis>:</para>
            <programlisting>//node[ node[@rel="hd" and @root="krijg"] and node[@rel="su"]/@index=node[@rel="vc"]/node[@rel="obj2"]/@index ]</programlisting>
            <para>(This query was taken from the <link
                    xlink:href="http://www.let.rug.nl/~vannoord/alp/Alpino/TreebankTools.html"
                    >manual for Treebank Tools</link>, which contains some more interesting
                queries.)</para>
            <para>Please do note that Dact expects queries that return nodes. A highlight query
                returning the value of an attribute of a node won’t highlight any nodes.</para>
        </sect2>
        <sect2>
            <title>Filtering a corpus</title>
            <para>The left pane shows a list of corpus entries, where each entry represents a parsed
                sentence. When viewing large corpora, it is often more interesting to look at
                particular entries. You can filter a corpus using an XPath query, where only the
                entries with nodes matching the query will be shown. A filter query can be typed in
                the field above the list of corpus entries: </para>
            <figure>
                <title>Filtering entries</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/filter-entry.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>After typing the query, press the <emphasis role="italic">Enter</emphasis> key,
                and Dact will start filtering the corpus. If you want to interrupt filtering, press
                    the <emphasis role="italic">Esc</emphasis> key.</para>
            <para>Using <emphasis role="italic">Next</emphasis> and <emphasis role="italic"
                    >Previous</emphasis> arrows in the top left menu bar, you can walk through each
                found entry. Or you can use the <emphasis role="italic"
                    >Ctrl+Down</emphasis> and <emphasis role="italic"
                >Ctrl+Up</emphasis> shortcuts.</para>
        </sect2>
        <sect2>
            <title>Highlighting</title>
            <para>After selecting an entry, its parse tree is shown in the right pane. All nodes
                matching an XPath query can be highlighted, this makes it easier to spot interesting
                phenomena. Entries can be highlighted by entering an XPath query:</para>
            <figure>
                <title>Highlighting nodes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="../images/highlight-entry.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Initially, the filter query is copied as the highlight query.</para>
            <figure>
                <title>Highlighted nodes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="../images/tree-highlighted.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Matching nodes will be highlighted in the tree in green. The buttons <emphasis
                    role="italic">Zoom In</emphasis> and <emphasis role="italic">Zoom
                Out</emphasis> can be used to scale the tree. <emphasis role="italic">Previous
                    Node</emphasis> and <emphasis role="italic">Next Node</emphasis> will walk you
                through all the matching nodes. You can use <emphasis role="italic"
                    >Ctrl+Left</emphasis> and<emphasis role="italic">Ctrl+Right</emphasis> as well.
                This node will then be marked by a slightly thicker border. When zoomed in, it also
                focusses on the node, making sure it is visible. Normally, the scroll wheel is used
                for panning the tree. but when you press<emphasis role="italic">Ctrl</emphasis>,
                scrolling will zoom the tree. <emphasis role="italic"
                    >Ctrl+=</emphasis> and <emphasis role="italic">Ctrl+-</emphasis> can also be
                used to zoom in and out, and <emphasis role="italic">Ctrl+0</emphasis> resets the
                zoom level to show the whole tree.</para>
            <para>The leaf nodes have tooltips showing more details about the node.</para>
            <para>Below the tree the bracketed sentence is shown, and the parts in the sentence
                represented by the matching nodes are surrounded by square brackets.</para>
        </sect2>
        <sect2>
            <title>Gathering statistics</title>
            <para>The Statistics window can be found in the <emphasis role="italic"
                >Tools</emphasis> menu, or using <emphasis role="italic">Ctrl+t</emphasis>.</para>
            <para>The Statistics window shows which values can be found for a certain attribute of
                the matching nodes throughout the corpus. These nodes can be filtered using the same
                XPath queries. If a node does match the filter, but does not have the attribute, it
                won’t be counted.</para>
            <figure>
                <title>Statistics window</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="../images/statistics-window.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Make sure to use a filter which matches the nodes you want to know the values of.
                For example, say we wanted to know how often every preposition occurs in a
                preposition phrase. We need to filter for the preposition nodes that are children of
                a preposition phrase node:</para>
            <programlisting>//node[@cat="pp"]/node[@pt="vz"]</programlisting>
            <para>If you are unsure whether your filter will match too much or too little, try to
                test it visually in the tree by using it as the highlight query.</para>
            <para>Because we want to know how often the word occurs, we select <emphasis
                    role="italic">word</emphasis> or <emphasis role="italic"
                >lemma</emphasis>.</para>
            <para>The <emphasis role="italic">result</emphasis> column shows all the distinct values
                found, and the <emphasis role="italic">count</emphasis> column shows how often these
                values where encountered. The <emphasis role="italic">percentage</emphasis> column
                puts this number into perspective by showing how much this is as a percentage of the
                total count of found values. This total is shown in the bottom right of the
                window.</para>
            <para>You can double-click one of the rows to search for all nodes that together are
                summed up in that row.</para>
        </sect2>
        <sect2>
            <title>Bracketed sentences</title>
            <para/>
            <para>To quickly get an impression which part of a sentence matches a query, you can use
                    the <emphasis role="italic">Bracketed sentences</emphasis>window in
                    the <emphasis role="italic">View</emphasis> menu. Or by using <emphasis
                    role="italic">Ctrl+b</emphasis>.</para>
            <figure>
                <title>Bracketed sentences window</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="../images/bracketed-sentences-window.png"
                        />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>The window shows the part of a sentence which matches the query between brackets
                for all the sentences in the corpus where at least one matching node is found.
                Single clicking on one of these sentences will draw its tree in the Main Window.
                Double clicking a sentence will bring the Main Window with the tree to the
                front.</para>
            <para>You can select alternative display modes using the dropdown menu. Currently three
                methods are implemented:</para>
            <itemizedlist>
                <listitem>
                    <para><emphasis role="italic">Complete Sentence</emphasis> shows the matching
                        nodes in the sentence on a different background. Nested matches have a more
                        opaque background.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Only Matches</emphasis> shows only partial
                        sentences of the nodes that matched. One match or nested match per line.
                        Currently because of the way this view is implemented the matches cannot be
                        sorted.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Keywords in Context</emphasis> shows all the
                        matches directly underneath each other and prints the rest of the sentence
                        left and right of the match. The colors can be configured in Dact’s
                        preference window.</para>
                </listitem>
            </itemizedlist>
        </sect2>
    </sect1>
</article>
